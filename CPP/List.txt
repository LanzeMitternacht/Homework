#include <iostream>
#include <exception>

using namespace std;

template<typename T>
struct List {
    struct Node {
        T m_value;
        Node* m_next;
        Node(T value, Node* next = nullptr) : m_value(value), m_next(next) {}
    };
    Node* head;

    List() : head(nullptr) {}
    List(const List& rhs): head(nullptr){
        Node* node = rhs.head;
        while (node != nullptr) {
            push_back(node->m_value);
            node = node->m_next;
        }
    }
    List& operator=(const List& rhs) {
        if (this != &rhs) {
            clear();
            Node* node = rhs.head;
            while (node != nullptr) {
                push_back(node->m_value);
                node = node->m_next;
            }
        }
        return *this;
    }
    ~List(){
        clear();
    }

    void push_front(T value) noexcept{
        if (!head) {
            head = new Node(value);
        }
        else {
            Node* node = head;
            head = new Node(value, node);
        }
    }

    void push_back(T value) noexcept{
        if (!head) {
            head = new Node(value);
        }
        else {
            Node* node = head;
            while (node->m_next) {
                node = node->m_next;
            }
            node->m_next = new Node(value);
        }
    }

    void pop_front() noexcept{
        if (head != nullptr) {
            Node* node = head;
            head = head->m_next;
            delete node;
        }
    }

    void pop_back() {
        if (!head) {
            throw out_of_range("List is empty");
        }
        else {
            Node* node = head;
            while (node->m_next && node->m_next->m_next) {
                node = node->m_next;
            }
            delete node->m_next;
            node->m_next = nullptr;
        }
    }

    bool empty() noexcept{
        return head == nullptr;
    }

    T& at(int index) {
        if (empty() || index > size()) {
            throw out_of_range("Index out of range");
        }
        Node* node = head;
        for (int i = 0; i < index; ++i) {
            node = node->m_next;
        }
        return node->m_value;
    }

    void clear() noexcept {
        while (head) {
            Node* node = head;
            head = head->m_next;
            delete node;
        }
    }

    int size() noexcept {
        int size = 0;
        Node* node = head;
        while (node) {
            node = node->m_next;
            ++size;
        }
        return size;
    }

    void insert(int index, T value) {
        if (index < 0 || index > size()) {
            throw out_of_range("Index out of range");
        }
        if (index == 0) {
            push_front(value);
        }
        else if (index == size()) {
            push_back(value);
        }
        else {
            Node* node = head;
            for (int i = 0; i < index - 1; ++i) {
                node = node->m_next;
            }
            node->m_next = new Node(value, node->m_next);
        }
    }

    void remove(int index) {
        if (index < 0 || index > size()){
            throw out_of_range("Index out of range");
        }
        if (index == 0) {
            pop_front();
        }
        else if (index == size() - 1) {
            pop_back();
        }
        else {
            Node* node = head;
            for (int i = 0; i < index - 1; ++i) {
                node = node->m_next;
            }
            Node* temp = node->m_next;
            node->m_next = temp->m_next;
            delete temp;
        }
    }
};


int main() {
    try {
        srand(time(NULL));
        List<int> l;
        for (int i = 0; i < 20; i++) {
            l.push_front(rand() % 20);
        }
        cout << l.size() << " " << l.at(4) << " " << l.at(19) << endl;
        cout << l.at(20) << endl; // error
        l.pop_back();
    }
    catch (out_of_range oor) {
        cout << "Exception: " << oor.what() << endl;
    }
    return 0;
}